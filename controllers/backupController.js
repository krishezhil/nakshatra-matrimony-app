const fs = require('fs');
const path = require('path');
const archiver = require('archiver');
const extract = require('extract-zip');
const log = require('../utils/logger');
const { getDataPath, getDataFilePath } = require('../utils/appData');
const { VERSION } = require('../utils/version');
const { 
  AppError, 
  ERROR_MESSAGES, 
  ERROR_TYPES, 
  handleControllerError, 
  asyncHandler 
} = require('../utils/errorHandler');

/**
 * Create and download backup ZIP file
 * GET /backup/download
 */
exports.createBackup = asyncHandler(async (req, res) => {
  const startTime = Date.now();
  log.info('Backup creation started', {
    source: 'BackupController',
    feature: 'BACKUP',
    operation: 'CREATE_BACKUP',
    requestId: req.headers['x-request-id'] || 'unknown'
  });

  try {
    const dataPath = getDataPath();
    const profilePath = getDataFilePath('profile.json');
    const gothramPath = getDataFilePath('gothram.json');

    // Check if files exist
    if (!fs.existsSync(profilePath)) {
      throw new AppError(
        'Profile data file not found. Cannot create backup.',
        404,
        ERROR_TYPES.FILE_SYSTEM,
        { profilePath }
      );
    }

    // Read profile data to get count
    let profileCount = 0;
    try {
      const profileData = JSON.parse(fs.readFileSync(profilePath, 'utf8'));
      profileCount = Array.isArray(profileData) ? profileData.length : 0;
    } catch (error) {
      log.warn('Could not read profile count', {
        source: 'BackupController',
        feature: 'BACKUP',
        error: error.message
      });
    }

    // Create backup metadata
    const metadata = {
      backupDate: new Date().toISOString(),
      backupDateFormatted: new Date().toLocaleString('en-IN', {
        dateStyle: 'medium',
        timeStyle: 'short'
      }),
      appVersion: VERSION,
      platform: process.platform,
      nodeVersion: process.version,
      profileCount: profileCount,
      filesIncluded: ['profile.json']
    };

    // Add gothram to metadata if exists
    if (fs.existsSync(gothramPath)) {
      metadata.filesIncluded.push('gothram.json');
    }

    // Generate backup filename with timestamp
    const timestamp = new Date().toISOString().replace(/:/g, '-').replace(/\..+/, '');
    const filename = `matrimony-backup-${timestamp}.zip`;

    log.debug('Creating backup ZIP', {
      source: 'BackupController',
      feature: 'BACKUP',
      filename,
      profileCount,
      filesIncluded: metadata.filesIncluded
    });

    // Set response headers for file download
    res.attachment(filename);
    res.setHeader('Content-Type', 'application/zip');

    // Create ZIP archive
    const archive = archiver('zip', {
      zlib: { level: 9 } // Maximum compression
    });

    // Handle archive errors
    archive.on('error', (err) => {
      log.error('Archive creation error', {
        source: 'BackupController',
        feature: 'BACKUP',
        error: err.message,
        stack: err.stack
      });
      throw new AppError(
        'Failed to create backup archive',
        500,
        ERROR_TYPES.FILE_SYSTEM,
        { error: err.message }
      );
    });

    // Track progress
    archive.on('progress', (progress) => {
      log.debug('Archive progress', {
        source: 'BackupController',
        feature: 'BACKUP',
        entries: progress.entries.processed,
        bytes: progress.fs.processedBytes
      });
    });

    // Pipe archive to response
    archive.pipe(res);

    // Add profile.json to archive
    archive.file(profilePath, { name: 'profile.json' });

    // Add gothram.json if exists
    if (fs.existsSync(gothramPath)) {
      archive.file(gothramPath, { name: 'gothram.json' });
    }

    // Add metadata file
    archive.append(JSON.stringify(metadata, null, 2), {
      name: 'backup-metadata.json'
    });

    // Add README with instructions
    const readmeContent = `# Matrimony Platform Backup
    
Backup Date: ${metadata.backupDateFormatted}
Profile Count: ${profileCount}
App Version: ${metadata.appVersion}

## Files Included:
${metadata.filesIncluded.map(f => `- ${f}`).join('\n')}

## How to Restore:
1. Login to the application as admin
2. Go to Admin Dashboard > Data Management
3. Click "Restore Backup"
4. Select this ZIP file
5. Confirm restoration

## Manual Upload to Google Drive:
1. Open Google Drive (drive.google.com)
2. Create a folder named "Matrimony Backups"
3. Upload this ZIP file to that folder
4. Keep multiple backup versions for safety

## Important Notes:
- Keep backups in a safe location
- Create regular backups (weekly recommended)
- Test restore process periodically
- Do not modify files inside this ZIP

Generated by கந்த கோட்டம் சேவா சங்கம் - திருமண இணையதளம்
`;

    archive.append(readmeContent, { name: 'README.txt' });

    // Finalize the archive
    await archive.finalize();

    const duration = Date.now() - startTime;
    log.info('Backup created successfully', {
      source: 'BackupController',
      feature: 'BACKUP',
      operation: 'CREATE_BACKUP',
      filename,
      profileCount,
      filesIncluded: metadata.filesIncluded,
      duration: `${duration}ms`
    });

  } catch (error) {
    log.error('Backup creation failed', {
      source: 'BackupController',
      feature: 'BACKUP',
      operation: 'CREATE_BACKUP',
      error: error.message,
      stack: error.stack
    });

    return handleControllerError(error, 'CREATE_BACKUP', 'createBackup', req, res, log);
  }
});

/**
 * Restore backup from uploaded ZIP file
 * POST /backup/restore
 */
exports.restoreBackup = asyncHandler(async (req, res) => {
  const startTime = Date.now();
  log.info('Backup restoration started', {
    source: 'BackupController',
    feature: 'BACKUP',
    operation: 'RESTORE_BACKUP',
    requestId: req.headers['x-request-id'] || 'unknown'
  });

  try {
    // Check if file was uploaded
    if (!req.file) {
      throw new AppError(
        'No backup file uploaded. Please select a ZIP file.',
        400,
        ERROR_TYPES.VALIDATION,
        { field: 'backup' }
      );
    }

    const uploadedFile = req.file;
    log.debug('Backup file uploaded', {
      source: 'BackupController',
      feature: 'BACKUP',
      filename: uploadedFile.originalname,
      size: uploadedFile.size,
      mimetype: uploadedFile.mimetype
    });

    // Validate file type
    if (!uploadedFile.originalname.endsWith('.zip')) {
      // Clean up uploaded file
      fs.unlinkSync(uploadedFile.path);
      
      throw new AppError(
        'Invalid file type. Please upload a ZIP file.',
        400,
        ERROR_TYPES.VALIDATION,
        { filename: uploadedFile.originalname }
      );
    }

    // Validate file size (max 50MB)
    const maxSize = 50 * 1024 * 1024; // 50MB
    if (uploadedFile.size > maxSize) {
      fs.unlinkSync(uploadedFile.path);
      
      throw new AppError(
        'Backup file is too large. Maximum size is 50MB.',
        400,
        ERROR_TYPES.VALIDATION,
        { size: uploadedFile.size, maxSize }
      );
    }

    // Create temporary extraction directory (PKG-compatible path)
    const actualDir = process.pkg ? process.cwd() : __dirname;
    const tempDir = process.pkg 
      ? path.join(actualDir, 'temp', `restore-${Date.now()}`)
      : path.join(__dirname, '..', 'temp', `restore-${Date.now()}`);
    
    try {
      fs.mkdirSync(tempDir, { recursive: true });
    } catch (error) {
      throw new AppError(
        'Failed to create temporary directory for backup extraction',
        500,
        ERROR_TYPES.FILE_SYSTEM,
        { tempDir, error: error.message }
      );
    }

    log.debug('Extracting backup ZIP', {
      source: 'BackupController',
      feature: 'BACKUP',
      source_file: uploadedFile.path,
      destination: tempDir
    });

    try {
      // Extract ZIP file
      await extract(uploadedFile.path, { dir: tempDir });

      // Read and validate metadata
      const metadataPath = path.join(tempDir, 'backup-metadata.json');
      if (!fs.existsSync(metadataPath)) {
        throw new AppError(
          'Invalid backup file. Metadata not found.',
          400,
          ERROR_TYPES.VALIDATION,
          { issue: 'Missing backup-metadata.json' }
        );
      }

      const metadata = JSON.parse(fs.readFileSync(metadataPath, 'utf8'));
      log.debug('Backup metadata loaded', {
        source: 'BackupController',
        feature: 'BACKUP',
        ...metadata
      });

      // Validate profile.json exists in backup
      const extractedProfilePath = path.join(tempDir, 'profile.json');
      if (!fs.existsSync(extractedProfilePath)) {
        throw new AppError(
          'Invalid backup file. Profile data not found.',
          400,
          ERROR_TYPES.VALIDATION,
          { issue: 'Missing profile.json' }
        );
      }

      // Validate JSON format
      let profileData;
      try {
        profileData = JSON.parse(fs.readFileSync(extractedProfilePath, 'utf8'));
        if (!Array.isArray(profileData)) {
          throw new Error('Profile data is not an array');
        }
      } catch (error) {
        throw new AppError(
          'Invalid backup file. Profile data is corrupted.',
          400,
          ERROR_TYPES.VALIDATION,
          { issue: error.message }
        );
      }

      // Create backup of existing data before restore
      const dataPath = getDataPath();
      const currentProfilePath = getDataFilePath('profile.json');
      const currentGothramPath = getDataFilePath('gothram.json');
      
      const preRestoreBackupDir = path.join(dataPath, `pre-restore-backup-${Date.now()}`);
      try {
        fs.mkdirSync(preRestoreBackupDir, { recursive: true });
      } catch (error) {
        log.warn('Could not create pre-restore backup directory', {
          source: 'BackupController',
          feature: 'BACKUP',
          backupDir: preRestoreBackupDir,
          error: error.message
        });
        // Continue without pre-restore backup if directory creation fails
      }

      // Backup current profile.json
      if (fs.existsSync(currentProfilePath)) {
        fs.copyFileSync(
          currentProfilePath,
          path.join(preRestoreBackupDir, 'profile.json.bak')
        );
      }

      // Backup current gothram.json
      if (fs.existsSync(currentGothramPath)) {
        fs.copyFileSync(
          currentGothramPath,
          path.join(preRestoreBackupDir, 'gothram.json.bak')
        );
      }

      log.info('Pre-restore backup created', {
        source: 'BackupController',
        feature: 'BACKUP',
        backupDir: preRestoreBackupDir
      });

      // Restore profile.json
      fs.copyFileSync(extractedProfilePath, currentProfilePath);
      log.info('Profile data restored', {
        source: 'BackupController',
        feature: 'BACKUP',
        profileCount: profileData.length
      });

      // Restore gothram.json if exists in backup
      const extractedGothramPath = path.join(tempDir, 'gothram.json');
      if (fs.existsSync(extractedGothramPath)) {
        fs.copyFileSync(extractedGothramPath, currentGothramPath);
        log.info('Gothram data restored', {
          source: 'BackupController',
          feature: 'BACKUP'
        });
      }

      // Reload profiles in memory (if applicable)
      try {
        const matchingController = require('./matchingController');
        if (matchingController.reloadProfiles) {
          matchingController.reloadProfiles();
          log.debug('Profiles reloaded in matching controller', {
            source: 'BackupController',
            feature: 'BACKUP'
          });
        }
      } catch (error) {
        log.warn('Could not reload profiles in matching controller', {
          source: 'BackupController',
          feature: 'BACKUP',
          error: error.message
        });
      }

      // Clean up temporary files
      fs.unlinkSync(uploadedFile.path);
      fs.rmSync(tempDir, { recursive: true, force: true });

      const duration = Date.now() - startTime;
      log.info('Backup restored successfully', {
        source: 'BackupController',
        feature: 'BACKUP',
        operation: 'RESTORE_BACKUP',
        profileCount: profileData.length,
        backupDate: metadata.backupDate,
        duration: `${duration}ms`
      });

      res.json({
        success: true,
        message: 'Backup restored successfully',
        data: {
          profileCount: profileData.length,
          backupDate: metadata.backupDateFormatted,
          filesRestored: metadata.filesIncluded
        }
      });

    } catch (error) {
      // Clean up on error
      if (fs.existsSync(tempDir)) {
        fs.rmSync(tempDir, { recursive: true, force: true });
      }
      if (fs.existsSync(uploadedFile.path)) {
        fs.unlinkSync(uploadedFile.path);
      }
      throw error;
    }

  } catch (error) {
    log.error('Backup restoration failed', {
      source: 'BackupController',
      feature: 'BACKUP',
      operation: 'RESTORE_BACKUP',
      error: error.message,
      stack: error.stack
    });

    return handleControllerError(error, 'RESTORE_BACKUP', 'restoreBackup', req, res, log);
  }
});

/**
 * Get backup information/status
 * GET /backup/info
 */
exports.getBackupInfo = asyncHandler(async (req, res) => {
  try {
    const profilePath = getDataFilePath('profile.json');
    const gothramPath = getDataFilePath('gothram.json');

    let profileCount = 0;
    let profileFileSize = 0;
    let lastModified = null;

    if (fs.existsSync(profilePath)) {
      const stats = fs.statSync(profilePath);
      profileFileSize = stats.size;
      lastModified = stats.mtime;

      try {
        const profileData = JSON.parse(fs.readFileSync(profilePath, 'utf8'));
        profileCount = Array.isArray(profileData) ? profileData.length : 0;
      } catch (error) {
        log.warn('Could not read profile data', {
          source: 'BackupController',
          feature: 'BACKUP',
          error: error.message
        });
      }
    }

    const info = {
      profileCount,
      profileFileSize,
      lastModified,
      filesAvailable: {
        'profile.json': fs.existsSync(profilePath),
        'gothram.json': fs.existsSync(gothramPath)
      },
      dataPath: getDataPath()
    };

    res.json({
      success: true,
      data: info
    });

  } catch (error) {
    return handleControllerError(error, 'GET_BACKUP_INFO', 'getBackupInfo', req, res, log);
  }
});
